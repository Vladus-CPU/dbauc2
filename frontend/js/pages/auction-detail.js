import {getAuctionBook, getMe, joinAuction, myParticipationStatus, placeAuctionOrder,} from '../api.js';
import { showToast } from '../ui/toast.js';
import { initAccessControl } from '../ui/session.js';

const params = new URLSearchParams(window.location.search);
const auctionId = Number(params.get('id'));
const summaryEl = document.getElementById('market-summary');
const titleEl = document.getElementById('market-title');
const statusEl = document.getElementById('market-status');
const metaEl = document.getElementById('market-meta');
const actionsEl = document.getElementById('market-actions');
const thumbEl = document.getElementById('market-thumbnail');
const bidsBody = document.getElementById('book-bids');
const asksBody = document.getElementById('book-asks');
const metricsEl = document.getElementById('market-metrics');
const formsEl = document.getElementById('market-forms');
const recentOrdersEl = document.getElementById('recent-orders');
const recentClearingEl = document.getElementById('recent-clearing');
const clearingChartEl = document.getElementById('clearing-chart');
const refreshBtn = document.getElementById('refresh-book');
// Optional container for history charts (add a <div id="auction-history-charts"></div> in HTML where desired)
const historyChartsEl = document.getElementById('auction-history-charts');
const priceDistEl = document.getElementById('price-distribution');

if (!auctionId) {
  summaryEl.innerHTML = '<p class="error">–ù–µ–≤—ñ—Ä–Ω–∏–π —ñ–¥–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ç–æ—Ä –∞—É–∫—Ü—ñ–æ–Ω—É</p>';
  throw new Error('Missing auction id');
}

let isLoading = false;

function formatNumber(value, options = {}) {
  if (value === null || value === undefined || Number.isNaN(Number(value))) {
    return '‚Äî';
  }
  const defaults = { minimumFractionDigits: 0, maximumFractionDigits: 6 };
  return Number(value).toLocaleString('uk-UA', { ...defaults, ...options });
}

function formatPrice(value) {
  return formatNumber(value, { minimumFractionDigits: 2, maximumFractionDigits: 6 });
}

function formatQty(value) {
  return formatNumber(value, { maximumFractionDigits: 6 });
}

function formatDate(value) {
  if (!value) return '‚Äî';
  const date = new Date(value);
  if (Number.isNaN(date.getTime())) return value;
  return new Intl.DateTimeFormat('uk-UA', {
    dateStyle: 'medium',
    timeStyle: 'short',
  }).format(date);
}

function tStatus(value) {
  const map = {
    collecting: '–ó–±—ñ—Ä –∑–∞—è–≤–æ–∫',
    cleared: '–í—ñ–¥–∫–ª—ñ—Ä–∏–Ω–≥–µ–Ω–æ',
    closed: '–ó–∞–∫—Ä–∏—Ç–æ',
  };
  if (!value) return '‚Äî';
  return map[value] || value;
}

function tSide(value) {
  const map = { bid: '–∫—É–ø—ñ–≤–ª—è', ask: '–ø—Ä–æ–¥–∞–∂' };
  if (!value) return '‚Äî';
  return map[value] || value;
}

function localizeErrorMessage(msg) {
  if (!msg) return '–°—Ç–∞–ª–∞—Å—è –Ω–µ–≤—ñ–¥–æ–º–∞ –ø–æ–º–∏–ª–∫–∞';
  const lower = msg.toLowerCase();
  if (lower.includes('unauthorized') || lower.includes('forbidden')) return '–ù–µ–º–∞—î –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø—É';
  if (lower.includes('not found')) return '–ù–µ –∑–Ω–∞–π–¥–µ–Ω–æ';
  if (lower.includes('invalid') || lower.includes('must')) return '–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ñ –¥–∞–Ω—ñ –∑–∞–ø–∏—Ç—É';
  if (lower.includes('timeout')) return '–ü–µ—Ä–µ–≤–∏—â–µ–Ω–æ —á–∞—Å –æ—á—ñ–∫—É–≤–∞–Ω–Ω—è';
  return msg;
}

function renderSummary(book) {
  const { auction } = book;
  titleEl.textContent = `${auction.product}`;
  statusEl.textContent = tStatus(auction.status);
  statusEl.className = `pill status-${auction.status}`;
  document.title = `${auction.product} ¬∑ –ö–Ω–∏–≥–∞ –∑–∞—è–≤–æ–∫ –∞—É–∫—Ü—ñ–æ–Ω—É`;

  const meta = [];
  meta.push(`<span><strong>–¢–∏–ø:</strong> ${auction.type}</span>`);
  meta.push(`<span><strong>k:</strong> ${formatNumber(auction.k_value, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</span>`);
  if (auction.window_start) {
    meta.push(`<span><strong>–ü–æ—á–∞—Ç–æ–∫:</strong> ${formatDate(auction.window_start)}</span>`);
  }
  if (auction.window_end) {
    meta.push(`<span><strong>–ö—ñ–Ω–µ—Ü—å:</strong> ${formatDate(auction.window_end)}</span>`);
  }
  meta.push(`<span><strong>–°—Ç–≤–æ—Ä–µ–Ω–æ:</strong> ${formatDate(auction.created_at)}</span>`);
  metaEl.innerHTML = meta.join('');

  const firstSymbol = auction.product?.trim()?.charAt(0)?.toUpperCase();
  thumbEl.innerHTML = firstSymbol ? `<span>${firstSymbol}</span>` : '<span>üì¶</span>';

  actionsEl.innerHTML = '';
  const metrics = book.metrics;
  if (metrics.bestBid !== null || metrics.bestAsk !== null) {
    const best = document.createElement('div');
    best.className = 'market-summary__quote';
    best.innerHTML = `
      <div>
        <span class="muted">–ù–∞–π–∫—Ä–∞—â–∞ –∫—É–ø—ñ–≤–ª—è</span>
        <strong>${formatPrice(metrics.bestBid)}</strong>
      </div>
      <div>
        <span class="muted">–ù–∞–π–∫—Ä–∞—â–∏–π –ø—Ä–æ–¥–∞–∂</span>
        <strong>${formatPrice(metrics.bestAsk)}</strong>
      </div>
    `;
    actionsEl.append(best);
  }
}

function renderBook(book) {
  bidsBody.innerHTML = '';
  asksBody.innerHTML = '';
  const bidLevels = (book.book.bids || []).slice(0, 15);
  const askLevels = (book.book.asks || []).slice(0, 15);
  const maxBidCum = Math.max(...bidLevels.map(l => l.cumulativeQuantity || 0), 0);
  const maxAskCum = Math.max(...askLevels.map(l => l.cumulativeQuantity || 0), 0);
  bidLevels.forEach((level) => {
    const tr = document.createElement('tr');
    tr.className = 'bid-row';
    const depthPct = maxBidCum ? (level.cumulativeQuantity / maxBidCum) * 100 : 0;
    tr.innerHTML = `
      <td class="depth-cell"><div class="depth-bar depth-bar--bid" style="--d:${depthPct.toFixed(2)}%"></div><span>${formatPrice(level.price)}</span></td>
      <td>${formatQty(level.totalQuantity)}</td>
      <td>${level.orderCount}</td>
      <td>${formatQty(level.cumulativeQuantity)}</td>
    `;
    bidsBody.append(tr);
  });
  askLevels.forEach((level) => {
    const tr = document.createElement('tr');
    tr.className = 'ask-row';
    const depthPct = maxAskCum ? (level.cumulativeQuantity / maxAskCum) * 100 : 0;
    tr.innerHTML = `
      <td class="depth-cell"><div class="depth-bar depth-bar--ask" style="--d:${depthPct.toFixed(2)}%"></div><span>${formatPrice(level.price)}</span></td>
      <td>${formatQty(level.totalQuantity)}</td>
      <td>${level.orderCount}</td>
      <td>${formatQty(level.cumulativeQuantity)}</td>
    `;
    asksBody.append(tr);
  });
  if (!bidsBody.children.length) {
    bidsBody.innerHTML = '<tr><td colspan="4" class="muted">–ù–µ–º–∞—î –∞–∫—Ç–∏–≤–Ω–∏—Ö –∑–∞—è–≤–æ–∫</td></tr>';
  }
  if (!asksBody.children.length) {
    asksBody.innerHTML = '<tr><td colspan="4" class="muted">–ù–µ–º–∞—î –∞–∫—Ç–∏–≤–Ω–∏—Ö –∑–∞—è–≤–æ–∫</td></tr>';
  }
}

function renderMetrics(book) {
  const m = book.metrics;
  const history = window.__auctionMetricHistory || (window.__auctionMetricHistory = {
    spread: [],
    midPrice: [],
    depthImbalancePct: [],
    lastClearingPrice: []
  });
  const pushMetric = (key, val) => {
    if (typeof val === 'number' && isFinite(val)) {
      history[key].push(val);
      if (history[key].length > 120) history[key].shift();
    }
  };
  pushMetric('spread', m.spread);
  pushMetric('midPrice', m.midPrice);
  pushMetric('depthImbalancePct', typeof m.depthImbalance === 'number' ? m.depthImbalance * 100 : NaN);
  pushMetric('lastClearingPrice', m.lastClearingPrice);

  metricsEl.innerHTML = '';
  const rows = [
    ['–°–ø—Ä–µ–¥', m.spread, 'spread'],
    m.isCrossedMarket ? ['‚ö†Ô∏è –ü–µ—Ä–µ—Ö—Ä–µ—â–µ–Ω–∏–π —Ä–∏–Ω–æ–∫', '—Ç–∞–∫'] : null,
    ['–°–µ—Ä–µ–¥–Ω—è (mid) —Ü—ñ–Ω–∞', m.midPrice, 'midPrice'],
    ['–û–±—Å—è–≥ –∫—É–ø—ñ–≤–ª—ñ', m.totalBidQuantity],
    ['–û–±—Å—è–≥ –ø—Ä–æ–¥–∞–∂—É', m.totalAskQuantity],
    ['–ó–∞—è–≤–æ–∫ (bid)', m.bidOrderCount],
    ['–ó–∞—è–≤–æ–∫ (ask)', m.askOrderCount],
    ['–ì–ª–∏–±–∏–Ω–∞ –Ω–∞ –Ω–∞–π–∫—Ä–∞—â–æ–º—É bid', m.bestBidDepth],
    ['–ì–ª–∏–±–∏–Ω–∞ –Ω–∞ –Ω–∞–π–∫—Ä–∞—â–æ–º—É ask', m.bestAskDepth],
    ['–û—Ä–¥–µ—Ä—ñ–≤ @ –Ω–∞–π–∫. bid', m.bestBidOrders],
    ['–û—Ä–¥–µ—Ä—ñ–≤ @ –Ω–∞–π–∫. ask', m.bestAskOrders],
    ['Top3 –≥–ª–∏–±–∏–Ω–∞ bid', m.top3BidDepth],
    ['Top3 –≥–ª–∏–±–∏–Ω–∞ ask', m.top3AskDepth],
    ['Top3 –æ—Ä–¥–µ—Ä—ñ–≤ bid', m.top3BidOrders],
    ['Top3 –æ—Ä–¥–µ—Ä—ñ–≤ ask', m.top3AskOrders],
    ['–î–∏—Å–±–∞–ª–∞–Ω—Å –≥–ª–∏–±–∏–Ω–∏', typeof m.depthImbalance === 'number' ? (m.depthImbalance * 100) : m.depthImbalance, 'depthImbalancePct'],
    ['–û—Å—Ç–∞–Ω–Ω—è —Ü—ñ–Ω–∞ –∫–ª—ñ—Ä–∏–Ω–≥—É', m.lastClearingPrice, 'lastClearingPrice'],
    ['–û—Å—Ç–∞–Ω–Ω—ñ–π –æ–±—Å—è–≥ –∫–ª—ñ—Ä–∏–Ω–≥—É', m.lastClearingQuantity],
  ];
  const formatValue = (label, value) => {
    if (value === null || value === undefined) return '‚Äî';
    if (label.includes('–î–∏—Å–±–∞–ª–∞–Ω—Å') && typeof value === 'number') return `${formatNumber(value, { maximumFractionDigits: 2 })}%`;
    if (typeof value === 'number') return formatNumber(value);
    if (typeof value === 'string' && value.trim() === '') return '‚Äî';
    return value;
  };
  const chartable = new Set(['spread','midPrice','depthImbalancePct','lastClearingPrice']);

  function buildSparkline(data, { width = 70, height = 22, stroke = '#66c0f4', fill = 'rgba(102,192,244,0.18)' } = {}) {
    if (!data || data.length < 2) {
      return `<svg class="micro-chart" width="${width}" height="${height}" aria-hidden="true"></svg>`;
    }
    const slice = data.slice(-40); // last 40 points
    const min = Math.min(...slice);
    const max = Math.max(...slice);
    const span = max - min || 1;
    const pts = slice.map((v, i) => {
      const x = (i / (slice.length - 1)) * (width - 2) + 1;
      const y = height - 2 - ((v - min) / span) * (height - 4);
      return `${x.toFixed(2)},${y.toFixed(2)}`;
    }).join(' ');
    const area = `M1 ${height-1} L ${pts.replace(/ /g,' L ')} L ${width-1} ${height-1} Z`;
    return `<svg class="micro-chart" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" aria-hidden="true" preserveAspectRatio="none">
      <path class="micro-chart__area" d="${area}" fill="${fill}" stroke="none" />
      <polyline class="micro-chart__line" points="${pts}" fill="none" stroke="${stroke}" stroke-width="1.6" stroke-linejoin="round" stroke-linecap="round" />
    </svg>`;
  }

  rows.filter(Boolean).forEach(([label, value, key]) => {
    const dt = document.createElement('dt');
    dt.textContent = label;
    const dd = document.createElement('dd');
    if (key && chartable.has(key)) {
      const display = formatValue(label, value);
      let histKey = key;
      // unify mapping for depthImbalancePct
      if (key === 'depthImbalancePct') histKey = 'depthImbalancePct';
      const spark = buildSparkline(history[histKey], {
        stroke: key === 'depthImbalancePct' ? '#ff9393' : (key === 'spread' ? '#7ee787' : '#66c0f4'),
        fill: key === 'depthImbalancePct' ? 'rgba(255,105,97,0.18)' : 'rgba(102,192,244,0.18)'
      });
      dd.classList.add('metric-with-chart');
      dd.innerHTML = `<span class="metric-value">${display}</span>${spark}`;
    } else {
      dd.textContent = formatValue(label, value);
    }
    metricsEl.append(dt, dd);
  });
}

// --------- History (price & depth) ---------
let lastHistoryAt = 0;
async function fetchHistory() {
  if (!auctionId) return null;
  const now = Date.now();
  if (now - lastHistoryAt < 5000) return null; // throttle 5s
  lastHistoryAt = now;
  try {
    const r = await fetch(`/api/auctions/${auctionId}/history`);
    if (!r.ok) return null;
    return await r.json();
  } catch { return null; }
}

function buildLine(pts, {w=300,h=80,stroke='#66c0f4'}={}) {
  if (!pts || pts.length < 2) return `<svg width="${w}" height="${h}" class="micro-chart"></svg>`;
  const ys = pts.map(p=>p.price);
  const minY = Math.min(...ys), maxY = Math.max(...ys), span = maxY-minY||1;
  const coords = pts.map((p,i)=>{
    const x = (i/(pts.length-1))*(w-2)+1;
    const y = h-2-((p.price-minY)/span)*(h-4);
    return `${x.toFixed(2)},${y.toFixed(2)}`;
  }).join(' ');
  return `<svg width="${w}" height="${h}" viewBox="0 0 ${w} ${h}" class="micro-chart" preserveAspectRatio="none"><polyline points="${coords}" fill="none" stroke="${stroke}" stroke-width="1.4" stroke-linejoin="round" stroke-linecap="round"/></svg>`;
}

function buildDepth(curve, {w=300,h=110}={}) {
  const bids = (curve?.bids||[]).slice(0,50);
  const asks = (curve?.asks||[]).slice(0,50);
  if (!bids.length && !asks.length) return '<div class="muted">–ù–µ–º–∞—î –≥–ª–∏–±–∏–Ω–∏</div>';
  const prices = [...bids.map(b=>b.price),...asks.map(a=>a.price)];
  const cumVals = [...bids.map(b=>b.cum),...asks.map(a=>a.cum)];
  const minP=Math.min(...prices), maxP=Math.max(...prices), maxCum=Math.max(...cumVals,1);
  const pad=4;
  const sx=p=>pad+((p-minP)/(maxP-minP||1))*(w-pad*2);
  const sy=c=>h-pad-((c/maxCum)*(h-pad*2));
  const mkPath=(arr)=>arr.map((pt,i)=>`${i?'L':'M'}${sx(pt.price).toFixed(2)},${sy(pt.cum).toFixed(2)}`).join(' ');
  const bidPath = mkPath(bids);
  const askPath = mkPath(asks);
  return `<svg width="${w}" height="${h}" viewBox="0 0 ${w} ${h}" class="micro-chart" preserveAspectRatio="none">
    <path d="${bidPath}" fill="none" stroke="#2ecc71" stroke-width="1.5"/>
    <path d="${askPath}" fill="none" stroke="#ff7676" stroke-width="1.5"/>
  </svg>`;
}

async function updateHistoryCharts() {
  if (!historyChartsEl) return;
  const data = await fetchHistory();
  if (!data) return;
  const prices = (data.clearedSeries||[]).filter(p=>typeof p.price==='number');
  historyChartsEl.innerHTML = `
    <div style="display:flex;flex-wrap:wrap;gap:18px;align-items:flex-start;">
      <div>
        <div class="muted" style="font-size:0.65rem;margin-bottom:4px;letter-spacing:0.08em;">–¶—ñ–Ω–∏ –∫–ª—ñ—Ä–∏–Ω–≥—É</div>
        ${buildLine(prices,{})}
      </div>
      <div>
        <div class="muted" style="font-size:0.65rem;margin-bottom:4px;letter-spacing:0.08em;">–ö—É–º—É–ª—è—Ç–∏–≤–Ω–∞ –≥–ª–∏–±–∏–Ω–∞</div>
        ${buildDepth(data.bookCurve,{})}
      </div>
    </div>`;
}

// --------- Price distribution (Steam-like depth bars) ---------
async function updatePriceDistribution() {
  if (!priceDistEl) return;
  try {
    const res = await fetch(`/api/auctions/${auctionId}/distribution`);
    if (!res.ok) return;
    const dist = await res.json();
    const { bids=[], asks=[], mid } = dist;
    const maxQty = Math.max(...bids.map(b=>b.qty), ...asks.map(a=>a.qty), 1);
    const row = (side, o) => {
      const pct = (o.qty / maxQty) * 100;
      return `<div class="dist-row dist-${side}" style="--w:${pct.toFixed(2)}%;"><span class="p">${formatPrice(o.p)}</span><span class="q">${formatQty(o.qty)}</span><span class="c">${o.count}</span></div>`;
    };
    priceDistEl.innerHTML = `
      <div class="dist-wrap" style="display:flex;flex-wrap:wrap;gap:28px;">
        <div style="flex:1;min-width:240px;">
          <div class="muted" style="font-size:0.65rem;letter-spacing:0.08em;margin-bottom:4px;">BIDS</div>
          <div class="dist-col">${bids.slice(0,25).map(o=>row('bid',o)).join('')||'<div class="muted">‚Äî</div>'}</div>
        </div>
        <div style="flex:1;min-width:240px;">
          <div class="muted" style="font-size:0.65rem;letter-spacing:0.08em;margin-bottom:4px;">ASKS</div>
          <div class="dist-col">${asks.slice(0,25).map(o=>row('ask',o)).join('')||'<div class="muted">‚Äî</div>'}</div>
        </div>
        <div style="flex:0 0 160px;">
          <div class="muted" style="font-size:0.65rem;letter-spacing:0.08em;margin-bottom:4px;">MID</div>
          <div style="font-size:0.9rem;font-weight:600;">${mid?formatPrice(mid):'‚Äî'}</div>
        </div>
      </div>`;
  } catch {}
}

function renderOrdersList(book) {
  recentOrdersEl.innerHTML = '';
  const combined = [];
  (book.recentOrders?.bids || []).forEach((o) => combined.push({ ...o, side: 'bid' }));
  (book.recentOrders?.asks || []).forEach((o) => combined.push({ ...o, side: 'ask' }));
  combined.sort((a, b) => {
    const dateA = a.createdAt ? new Date(a.createdAt).getTime() : 0;
    const dateB = b.createdAt ? new Date(b.createdAt).getTime() : 0;
    return dateB - dateA;
  });
  combined.slice(0, 12).forEach((order) => {
    const li = document.createElement('li');
    const sideLabel = tSide(order.side).toUpperCase();
    li.innerHTML = `
      <div><strong>${sideLabel}</strong> ${formatQty(order.quantity)} @ ${formatPrice(order.price)}</div>
      <span>${formatDate(order.createdAt)}</span>
    `;
    recentOrdersEl.append(li);
  });
  if (!recentOrdersEl.children.length) {
    recentOrdersEl.innerHTML = '<li class="muted">–ù–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ –¥–∞–Ω–∏—Ö</li>';
  }
}

function renderClearing(book) {
  recentClearingEl.innerHTML = '';
  const data = book.recentClearing || [];
  data.forEach((entry) => {
    const li = document.createElement('li');
    li.innerHTML = `
      <div><strong>${formatQty(entry.quantity)}</strong> @ ${formatPrice(entry.price)}</div>
      <span>${formatDate(entry.createdAt)}</span>
    `;
    recentClearingEl.append(li);
  });
  if (!data.length) {
    recentClearingEl.innerHTML = '<li class="muted">–ö–ª—ñ—Ä–∏–Ω–≥—ñ–≤ —â–µ –Ω–µ –±—É–ª–æ</li>';
  }
  renderClearingChart(data);
}

function renderClearingChart(data) {
  clearingChartEl.innerHTML = '';
  if (!data || data.length < 2) {
    const empty = document.createElement('div');
    empty.className = 'market-chart__empty';
    empty.textContent = '–©–µ –Ω–µ–º–∞—î —ñ—Å—Ç–æ—Ä—ñ—ó —Ü—ñ–Ω';
    clearingChartEl.append(empty);
    return;
  }
  const ordered = [...data].slice(0, 30).reverse();
  const prices = ordered.map((d) => Number(d.price));
  const min = Math.min(...prices);
  const max = Math.max(...prices);
  const diff = max - min || 1;
  const points = ordered.map((entry, index) => {
    const x = (index / (ordered.length - 1)) * 100;
    const y = 100 - ((entry.price - min) / diff) * 100;
    return `${x},${y}`;
  }).join(' ');

  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  svg.setAttribute('viewBox', '0 0 100 100');
  svg.setAttribute('preserveAspectRatio', 'none');

  const polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
  polyline.setAttribute('points', points);
  polyline.setAttribute('fill', 'none');
  polyline.setAttribute('stroke', '#66c0f4');
  polyline.setAttribute('stroke-width', '2');
  polyline.setAttribute('stroke-linejoin', 'round');
  polyline.setAttribute('stroke-linecap', 'round');

  const areaPoints = `0,100 ${points} 100,100`;
  const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
  polygon.setAttribute('points', areaPoints);
  polygon.setAttribute('fill', 'rgba(102, 192, 244, 0.18)');

  svg.append(polygon, polyline);
  clearingChartEl.append(svg);
}

function renderForms(book, me, participation) {
  formsEl.innerHTML = '';
  const auction = book.auction;
  const isTrader = me?.authenticated && !me.user?.is_admin;
  if (!isTrader) {
    formsEl.innerHTML = '<p class="muted">–£–≤—ñ–π–¥—ñ—Ç—å —è–∫ —Ç—Ä–µ–π–¥–µ—Ä, —â–æ–± –ø–æ–¥–∞–≤–∞—Ç–∏ –∑–∞—è–≤–∫–∏.</p>';
    return;
  }
  const joinStatus = participation?.status || null;
  const statusLabel = document.createElement('div');
  statusLabel.innerHTML = `<strong>–°—Ç–∞—Ç—É—Å —É—á–∞—Å—Ç—ñ:</strong> ${joinStatus || '–Ω–µ –ø—Ä–∏—î–¥–Ω–∞–≤—Å—è'}`;
  if (participation?.account_id) {
    statusLabel.innerHTML += `<span class="muted"> ¬∑ accountId ${participation.account_id}</span>`;
  }
  formsEl.append(statusLabel);

  if (auction.type === 'open' && auction.status === 'collecting') {
    const note = document.createElement('p');
    note.className = 'muted';
    note.textContent = '–í—ñ–¥–∫—Ä–∏—Ç–∏–π –∞—É–∫—Ü—ñ–æ–Ω ‚Äî –ø—Ä–∏—î–¥–Ω–∞–Ω–Ω—è –Ω–µ –ø–æ—Ç—Ä—ñ–±–Ω–µ, –º–æ–∂–Ω–∞ –æ–¥—Ä–∞–∑—É –ø–æ–¥–∞–≤–∞—Ç–∏ –∑–∞—è–≤–∫–∏.';
    formsEl.append(note);
  }

  if (auction.status === 'collecting' && auction.type === 'closed' && joinStatus !== 'approved') {
    if (joinStatus === 'pending') {
      const note = document.createElement('p');
      note.className = 'muted';
      note.textContent = '–ó–∞–ø–∏—Ç –Ω–∞ —É—á–∞—Å—Ç—å –æ—á—ñ–∫—É—î –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è –∞–¥–º—ñ–Ω—ñ—Å—Ç—Ä–∞—Ç–æ—Ä–∞.';
      formsEl.append(note);
    } else {
      const form = document.createElement('form');
      form.innerHTML = `
        <label for="participation-account">accountId (–æ–ø—Ü—ñ–π–Ω–æ)</label>
        <input id="participation-account" type="number" min="0" step="1" placeholder="ID —Ä–∞—Ö—É–Ω–∫—É" />
        <button type="submit" class="btn">–ü–æ–¥–∞—Ç–∏ –∑–∞—è–≤–∫—É –Ω–∞ —É—á–∞—Å—Ç—å</button>
      `;
      form.addEventListener('submit', async (event) => {
        event.preventDefault();
        const accountIdValue = Number(form.querySelector('input').value);
        try {
          await joinAuction(auctionId, Number.isFinite(accountIdValue) && accountIdValue > 0 ? accountIdValue : undefined);
          showToast('–ó–∞–ø–∏—Ç –Ω–∞ —É—á–∞—Å—Ç—å –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ', 'success');
          await load();
        } catch (error) {
          showToast(localizeErrorMessage(error?.message || '–ù–µ –≤–¥–∞–ª–æ—Å—è –ø–æ–¥–∞—Ç–∏ –∑–∞—è–≤–∫—É'), 'error');
        }
      });
      formsEl.append(form);
    }
  }

  const canPlaceOrders = auction.status === 'collecting' && (
    auction.type === 'open' || joinStatus === 'approved'
  );
  if (!canPlaceOrders) {
    const note = document.createElement('p');
    note.className = 'muted';
    if (auction.status !== 'collecting') {
      note.textContent = '–ê—É–∫—Ü—ñ–æ–Ω –≤–∂–µ –∑–∞–∫—Ä–∏—Ç–æ –¥–ª—è –ø–æ–¥–∞—á—ñ –∑–∞—è–≤–æ–∫.';
    } else if (auction.type === 'closed') {
      note.textContent = '–û—á—ñ–∫—É–π—Ç–µ –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è —É—á–∞—Å—Ç—ñ, —â–æ–± –ø–æ–¥–∞–≤–∞—Ç–∏ –∑–∞—è–≤–∫–∏.';
    }
    formsEl.append(note);
    return;
  }

  const orderForm = document.createElement('form');
  orderForm.innerHTML = `
    <label for="order-side">–¢–∏–ø –æ—Ä–¥–µ—Ä—É</label>
    <select id="order-side" name="side">
      <option value="bid">–ö—É–ø–∏—Ç–∏</option>
      <option value="ask">–ü—Ä–æ–¥–∞—Ç–∏</option>
    </select>
    <div class="market-form__split">
      <label>
        –¶—ñ–Ω–∞
        <input name="price" type="number" min="0" step="0.000001" required />
      </label>
      <label>
        –ö—ñ–ª—å–∫—ñ—Å—Ç—å
        <input name="quantity" type="number" min="0" step="0.000001" required />
      </label>
    </div>
    <button type="submit" class="btn">–ü–æ–¥–∞—Ç–∏ –æ—Ä–¥–µ—Ä</button>
  `;
  orderForm.addEventListener('submit', async (event) => {
    event.preventDefault();
    const formData = new FormData(orderForm);
    const payload = {
      type: formData.get('side'),
      price: Number(formData.get('price')),
      quantity: Number(formData.get('quantity')),
    };
    try {
      await placeAuctionOrder(auctionId, payload);
      showToast('–û—Ä–¥–µ—Ä –ø—Ä–∏–π–Ω—è—Ç–æ', 'success');
      orderForm.reset();
      await load();
    } catch (error) {
  showToast(localizeErrorMessage(error?.message || '–ù–µ –≤–¥–∞–ª–æ—Å—è –ø–æ–¥–∞—Ç–∏ –æ—Ä–¥–µ—Ä'), 'error');
    }
  });
  formsEl.append(orderForm);
}

async function load() {
  if (isLoading) return;
  isLoading = true;
  summaryEl.classList.add('is-loading');
  try {
    const [me, book] = await Promise.all([
      getMe().catch(() => ({ authenticated: false })),
      getAuctionBook(auctionId),
    ]);
    let participation = null;
    if (me?.authenticated && !me.user?.is_admin) {
      participation = await myParticipationStatus(auctionId).catch(() => null);
    }
    renderSummary(book);
    renderBook(book);
    renderMetrics(book);
    renderOrdersList(book);
    renderClearing(book);
    renderForms(book, me, participation);
    try {
      if (book?.auction?.status && book.auction.status !== 'collecting') {
        if (window.__auctionRefreshTimer) {
          clearInterval(window.__auctionRefreshTimer);
          window.__auctionRefreshTimer = null;
        }
      }
    } catch {}
  } catch (error) {
  summaryEl.innerHTML = `<p class="error">${localizeErrorMessage(error?.message || '–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –∞—É–∫—Ü—ñ–æ–Ω')}</p>`;
    console.error(error);
  } finally {
    summaryEl.classList.remove('is-loading');
    isLoading = false;
  }
}

refreshBtn.addEventListener('click', () => {
  load().then(() => showToast('–ö–Ω–∏–≥–∞ –∑–∞—è–≤–æ–∫ –æ–Ω–æ–≤–ª–µ–Ω–∞', 'info'));
});

document.addEventListener('DOMContentLoaded', async () => {
  await initAccessControl();
  await load();
  updateHistoryCharts();
  updatePriceDistribution();
  if (!window.__auctionRefreshTimer) {
    window.__auctionRefreshTimer = setInterval(() => {
      if (document.hidden) return;
      if (isLoading) return;
      load();
      updateHistoryCharts();
      updatePriceDistribution();
    }, 15000);
  }
  // kick initial charts
  updateHistoryCharts();
  window.addEventListener('beforeunload', () => {
    if (window.__auctionRefreshTimer) {
      clearInterval(window.__auctionRefreshTimer);
      window.__auctionRefreshTimer = null;
    }
  });
});
